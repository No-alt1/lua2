-- Function to create the GUI
function create_gui(game_id, game_name, game_thumbnail)
    -- Create a screen GUI
    local screen_gui = Instance.new("ScreenGui")
    screen_gui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

    -- Create a Frame for the GUI (Make it movable and modern)
    local frame = Instance.new("Frame")
    frame.Parent = screen_gui
    frame.Size = UDim2.new(0, 400, 0, 350)  -- Adjusted size for the image and buttons
    frame.Position = UDim2.new(0.5, -200, 0.5, -175)  -- Centered on the screen

    -- Modern background with gradient
    local ui_gradient = Instance.new("UIGradient")
    ui_gradient.Parent = frame
    ui_gradient.Color = ColorSequence.new(
        Color3.fromRGB(20, 20, 20),  -- Dark top color
        Color3.fromRGB(0, 0, 0)  -- Black bottom color
    )
    ui_gradient.Rotation = 45  -- Make the gradient diagonal

    -- Make the frame movable
    local dragging = false
    local drag_start = nil
    local start_position = nil

    frame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            drag_start = input.Position
            start_position = frame.Position
        end
    end)

    frame.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
        end
    end)

    frame.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            local delta = input.Position - drag_start
            frame.Position = UDim2.new(start_position.X.Scale, start_position.X.Offset + delta.X, start_position.Y.Scale, start_position.Y.Offset + delta.Y)
        end
    end)

    -- Create an ImageLabel to display the player's 2D avatar
    local avatar_image_label = Instance.new("ImageLabel")
    avatar_image_label.Parent = frame
    avatar_image_label.Size = UDim2.new(0, 100, 0, 100)  -- Size of the avatar
    avatar_image_label.Position = UDim2.new(0.25, -50, 0, -80)  -- Positioned above the buttons
    avatar_image_label.BackgroundTransparency = 1  -- No background

    -- Fetch the player's avatar thumbnail using the correct method
    local player = game.Players.LocalPlayer
    local avatar_image = game.Players:GetUserThumbnailAsync(player.UserId, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size180x180)

    avatar_image_label.Image = avatar_image  -- Set the avatar image

    -- Create a TextLabel for the game name (Centered on the middle of the game icon picture)
    local name_label = Instance.new("TextLabel")
    name_label.Parent = frame  -- Parent it inside the frame to move together
    name_label.Size = UDim2.new(0, 180, 0, 40)  -- Adjust size to fit within the game thumbnail
    name_label.Position = UDim2.new(0.5, -90, 0, 50)  -- Positioned in the middle of the game thumbnail
    name_label.Text = game_name  -- Display the game name
    name_label.TextSize = 18
    name_label.TextColor3 = Color3.fromRGB(255, 255, 255)
    name_label.BackgroundTransparency = 1
    name_label.TextXAlignment = Enum.TextXAlignment.Center
    name_label.TextYAlignment = Enum.TextYAlignment.Center

    -- Create an ImageLabel for the game thumbnail (game picture)
    local game_thumbnail_label = Instance.new("ImageLabel")
    game_thumbnail_label.Parent = frame
    game_thumbnail_label.Size = UDim2.new(0, 180, 0, 180)  -- Adjusted size for the game thumbnail
    game_thumbnail_label.Position = UDim2.new(0.5, -90, 0, 100)  -- Positioned below the game name
    game_thumbnail_label.BackgroundTransparency = 1  -- No background

    -- Fetch and set the game thumbnail image
    game_thumbnail_label.Image = game_thumbnail  -- Set the game thumbnail image

    -- Create a TextLabel for the player name (Positioned next to the player avatar)
    local player_name_label = Instance.new("TextLabel")
    player_name_label.Parent = frame  -- Parent it inside the frame to move together
    player_name_label.Size = UDim2.new(0, 250, 0, 30)
    player_name_label.Position = UDim2.new(0.5, -125, 0, 20)  -- Positioned next to the player avatar
    player_name_label.Text = "Player: " .. player.Name  -- Display the player name
    player_name_label.TextSize = 18
    player_name_label.TextColor3 = Color3.fromRGB(255, 255, 255)
    player_name_label.BackgroundTransparency = 1
    player_name_label.TextXAlignment = Enum.TextXAlignment.Left
    player_name_label.TextYAlignment = Enum.TextYAlignment.Center

    -- Create a black modern "Load" button on the left
    local load_button = Instance.new("TextButton")
    load_button.Parent = frame
    load_button.Size = UDim2.new(0, 150, 0, 50)  -- Button size
    load_button.Position = UDim2.new(0.25, -75, 0.8, 0)  -- Positioned on the left
    load_button.Text = "Load"
    load_button.BackgroundColor3 = Color3.fromRGB(0, 0, 0)  -- Black background
    load_button.TextSize = 20
    load_button.TextColor3 = Color3.fromRGB(255, 255, 255)  -- White text
    load_button.TextStrokeTransparency = 0.8  -- Subtle text stroke for contrast

    -- Apply rounded corners to the "Load" button
    local load_button_corners = Instance.new("UICorner")
    load_button_corners.CornerRadius = UDim.new(0, 12)
    load_button_corners.Parent = load_button

    -- Create a black modern "Exit" button on the right
    local exit_button = Instance.new("TextButton")
    exit_button.Parent = frame
    exit_button.Size = UDim2.new(0, 150, 0, 50)  -- Button size
    exit_button.Position = UDim2.new(0.75, -75, 0.8, 0)  -- Positioned on the right
    exit_button.Text = "Exit"
    exit_button.BackgroundColor3 = Color3.fromRGB(0, 0, 0)  -- Black background
    exit_button.TextSize = 20
    exit_button.TextColor3 = Color3.fromRGB(255, 255, 255)  -- White text
    exit_button.TextStrokeTransparency = 0.8  -- Subtle text stroke for contrast

    -- Apply rounded corners to the "Exit" button
    local exit_button_corners = Instance.new("UICorner")
    exit_button_corners.CornerRadius = UDim.new(0, 12)
    exit_button_corners.Parent = exit_button

    -- Smooth animations for button hover effect
    load_button.MouseEnter:Connect(function()
        load_button:TweenSize(UDim2.new(0, 160, 0, 55), "Out", "Quad", 0.2, true)
        load_button.BackgroundColor3 = Color3.fromRGB(50, 50, 50)  -- Darker gray on hover
    end)
    load_button.MouseLeave:Connect(function()
        load_button:TweenSize(UDim2.new(0, 150, 0, 50), "Out", "Quad", 0.2, true)
        load_button.BackgroundColor3 = Color3.fromRGB(0, 0, 0)  -- Back to original black
    end)

    exit_button.MouseEnter:Connect(function()
        exit_button:TweenSize(UDim2.new(0, 160, 0, 55), "Out", "Quad", 0.2, true)
        exit_button.BackgroundColor3 = Color3.fromRGB(50, 50, 50)  -- Darker gray on hover
    end)
    exit_button.MouseLeave:Connect(function()
        exit_button:TweenSize(UDim2.new(0, 150, 0, 50), "Out", "Quad", 0.2, true)
        exit_button.BackgroundColor3 = Color3.fromRGB(0, 0, 0)  -- Back to original black
    end)

    -- Button Functions
    load_button.MouseButton1Click:Connect(function()
        print("Load button clicked!")
local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'

local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

local Window = Library:CreateWindow({
    Title = 'M3C Universal Cheats',
    Center = true,
    AutoShow = true,
})

local Tabs = {
    Main = Window:AddTab('Main'),
    Second = Window:AddTab('Fun cheats'),
    Settings = Window:AddTab('UI Settings'),
}

-- Create the ESP variable
local ESP = loadstring(game:HttpGet("https://raw.githubusercontent.com/No-alt1/lua2/refs/heads/main/EspLua"))()

-- Set initial ESP settings (all disabled)
ESP.Enabled = false
ESP.ShowBox = false
ESP.BoxType = "Corner Box Esp"
ESP.ShowName = false
ESP.ShowHealth = false
ESP.ShowTracer = false
ESP.ShowDistance = false

-- Variables
local fov = 250
local smoothing = 1
local aimbotEnabled = false
local fovCircleEnabled = false
local rgbEffectEnabled = false
local rgbDelay = 0.2
local fovColor = Color3.fromRGB(255, 128, 128)
local teamCheckEnabled = false
local rgbHue = 0
local currentTarget = nil
local instantLockEnabled = false

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local localPlayer = game.Players.LocalPlayer
local camera = workspace.CurrentCamera

-- FOV Circle Setup
local FOVring = Drawing.new("Circle")
FOVring.Visible = false
FOVring.Thickness = 1.5
FOVring.Radius = fov
FOVring.Transparency = 1
FOVring.Color = fovColor
FOVring.Position = UserInputService:GetMouseLocation()

-- Linear interpolation for colors
local function lerpColor(startColor, endColor, t)
    return startColor:Lerp(endColor, t)
end

-- Get the closest target to the crosshair
local function getClosest(cframe)
    local closestTarget = nil
    local closestDistance = math.huge

    for _, player in pairs(game.Players:GetPlayers()) do
        if player.Character and player.Character:FindFirstChild("Head") and player.Character:FindFirstChild("Humanoid") and player.Character:FindFirstChild("HumanoidRootPart") and player ~= localPlayer then
            if teamCheckEnabled and player.Team == localPlayer.Team then
                continue
            end

            local head = player.Character.Head
            local viewVector = (head.Position - camera.CFrame.Position).Unit
            local dotProduct = camera.CFrame.LookVector:Dot(viewVector)

            if dotProduct > 0 then
                local screenPoint, onScreen = camera:WorldToViewportPoint(head.Position)
                if onScreen then
                    local distance = (Vector2.new(screenPoint.X, screenPoint.Y) - UserInputService:GetMouseLocation()).Magnitude
                    if distance < closestDistance and distance <= fov then
                        closestDistance = distance
                        closestTarget = player
                    end
                end
            end
        end
    end

    return closestTarget
end

-- Update FOV Circle and RGB Effect
local function updateFOVCircle()
    if fovCircleEnabled then
        FOVring.Visible = true
        FOVring.Position = UserInputService:GetMouseLocation()
        FOVring.Radius = fov

        if rgbEffectEnabled then
            rgbHue = (rgbHue + rgbDelay * RunService.RenderStepped:Wait()) % 1
            FOVring.Color = Color3.fromHSV(rgbHue, 1, 1)
        else
            FOVring.Color = fovColor
        end
    else
        FOVring.Visible = false
    end
end

-- Aimbot logic
local loop
loop = RunService.RenderStepped:Connect(function()
    if aimbotEnabled then
        local pressed = UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2)

        if pressed then
            local newTarget = getClosest(camera.CFrame)
            if newTarget ~= currentTarget then
                currentTarget = newTarget
            end

            if currentTarget then
                local targetPosition = currentTarget.Character.Head.Position

                if instantLockEnabled then
                    camera.CFrame = CFrame.new(camera.CFrame.Position, targetPosition)
                else
                    local smoothCFrame = camera.CFrame:Lerp(CFrame.new(camera.CFrame.Position, targetPosition), math.clamp(smoothing / 10, 0.05, 0.2))
                    camera.CFrame = smoothCFrame
                end
            end
        else
            currentTarget = nil
        end
    else
        currentTarget = nil
    end

    updateFOVCircle()
end)

-- UI Setup
local LeftGroupBox = Tabs.Main:AddLeftGroupbox('Aimbot')

-- Aimbot Settings
LeftGroupBox:AddToggle('AimbotEnabled', {
    Text = 'Enable Aimbot',
    Default = false,  -- Default value is off
    Tooltip = 'Enable or disable the aimbot.',
    Callback = function(Value)
        aimbotEnabled = Value
        if aimbotEnabled then
            -- Reset the currentTarget when enabling the aimbot
            currentTarget = getClosest(camera.CFrame)  -- Lock onto the closest target when aimbot is enabled
        else
            -- Reset currentTarget when aimbot is disabled
            currentTarget = nil
        end
    end
})

-- New Aimbot Instant Lock Toggle
LeftGroupBox:AddToggle('InstantLock', {
    Text = 'Enable Instant Lock',
    Default = false,  -- Default value is off
    Tooltip = 'Lock instantly onto target\'s head without prediction or smoothing.',
    Callback = function(Value)
        instantLockEnabled = Value
    end
})

-- New Team Check Toggle
LeftGroupBox:AddToggle('TeamCheck', {
    Text = 'Enable Team Check',
    Default = false,
    Tooltip = 'Prevent locking onto teammates.',
    Callback = function(Value)
        teamCheckEnabled = Value
    end
})

-- Aimbot Smoothing Slider
LeftGroupBox:AddSlider('AimbotSmoothing', {
    Text = 'Aimbot Smoothing',
    Default = 1,
    Min = 0,
    Max = 10,
    Rounding = 1,
    Tooltip = 'Adjust the smoothing of the aimbot.',
    Callback = function(Value)
        smoothing = Value
    end
})

-- Add FOV Circle GroupBox (separate group box for FOV circle)
local FOVGroupBox = Tabs.Main:AddLeftGroupbox('FOV Circle')

-- FOV Circle Toggle
FOVGroupBox:AddToggle('FovCircleToggle', {
    Text = 'Enable FOV Circle',
    Default = false,
    Tooltip = 'Enable or disable the FOV circle.',
    Callback = function(Value)
        fovCircleEnabled = Value
        updateFOVCircle() -- Update the FOV circle visibility based on toggle
    end
})

-- FOV Circle Radius Slider
FOVGroupBox:AddSlider('FovSlider', {
    Text = 'FOV Circle Radius',
    Default = 250,
    Min = 1,
    Max = 1000,
    Rounding = 0,
    Tooltip = 'Adjust the radius of the FOV circle.',
    Callback = function(Value)
        fov = Value
        updateFOVCircle() -- Update the FOV circle radius based on the slider
    end
})

-- RGB Effect Toggle
FOVGroupBox:AddToggle('RgbEffectToggle', {
    Text = 'Enable RGB Effect',
    Default = false,
    Tooltip = 'Enable or disable the RGB color cycling effect on the FOV circle.',
    Callback = function(Value)
        rgbEffectEnabled = Value
        updateFOVCircle() -- Update the RGB effect based on the toggle
    end
})

-- RGB Effect Delay Slider
FOVGroupBox:AddSlider('RgbDelaySlider', {
    Text = 'RGB Effect Delay (s)',
    Default = rgbDelay,
    Min = 0.01,
    Max = 1,
    Rounding = 2,
    Tooltip = 'Adjust the delay for the RGB color transition. Lower values will make the transition faster.',
    Callback = function(Value)
        rgbDelay = Value
    end
})

-- Add GroupBox for ESP Settings (right)
local ESPGroupBox = Tabs.Main:AddRightGroupbox('ESP')

-- Manual Toggle for ESP and its options
ESPGroupBox:AddToggle('ESPEnabled', {
    Text = 'Enable ESP',
    Default = false,  -- Default value is off
    Tooltip = 'Enable or disable ESP',
    Callback = function(Value)
        ESP.Enabled = Value
    end
})

-- Manual toggle for individual ESP features
ESPGroupBox:AddToggle('ShowBox', {
    Text = 'Show Box',
    Default = false,  -- Default value is off
    Tooltip = 'Enable or disable ESP boxes',
    Callback = function(Value)
        ESP.ShowBox = Value
    end
})

ESPGroupBox:AddToggle('ShowName', {
    Text = 'Show Name',
    Default = false,  -- Default value is off
    Tooltip = 'Enable or disable player names in ESP',
    Callback = function(Value)
        ESP.ShowName = Value
    end
})

ESPGroupBox:AddToggle('ShowHealth', {
    Text = 'Show Health',
    Default = false,  -- Default value is off
    Tooltip = 'Enable or disable player healthbar in ESP',
    Callback = function(Value)
        ESP.ShowHealth = Value
    end
})

ESPGroupBox:AddToggle('ShowTracer', {
    Text = 'Show Tracers',
    Default = false,  -- Default value is off
    Tooltip = 'Enable or disable tracers in ESP',
    Callback = function(Value)
        ESP.ShowTracer = Value
    end
})

ESPGroupBox:AddToggle('ShowDistance', {
    Text = 'Show Distance',
    Default = false,  -- Default value is off
    Tooltip = 'Enable or disable distance display in ESP',
    Callback = function(Value)
        ESP.ShowDistance = Value
    end
})

local HitBoxTab = Tabs.Main:AddRightGroupbox('HitBox Expander')

-- Variables for customization
_G.HeadExpanderEnabled = false
_G.HeadSize = 15
_G.HeadTransparency = 0.5
_G.HeadColor = Color3.fromRGB(255, 0, 0)
_G.UseRGBColor = false
_G.RGBDelay = 0.05 -- Default RGB transition delay (in seconds)

-- Table to store original head properties
local originalProperties = {}

-- RGB Color Cycle Function
local function RGBColorCycle()
    local hue = 0
    return function()
        hue = (hue + 0.001) % 1 -- Increment hue smoothly and loop back to 0
        return Color3.fromHSV(hue, 1, 1)
    end
end

local GetNextRGBColor = RGBColorCycle()

-- Toggle for Head HitBox Expander
HitBoxTab:AddToggle('HeadExpanderToggle', {
    Text = 'Enable Head HitBox Expander',
    Default = false,
    Tooltip = 'Toggles the Head HitBox Expander on or off.',
    Callback = function(Value)
        _G.HeadExpanderEnabled = Value
        if not Value then
            -- Restore original head properties
            for _, player in ipairs(game:GetService('Players'):GetPlayers()) do
                if player ~= game:GetService('Players').LocalPlayer and player.Character and player.Character:FindFirstChild('Head') then
                    local head = player.Character.Head
                    if originalProperties[head] then
                        pcall(function()
                            head.Size = originalProperties[head].Size
                            head.Transparency = originalProperties[head].Transparency
                            head.BrickColor = originalProperties[head].BrickColor
                            head.Material = originalProperties[head].Material
                            head.CanCollide = originalProperties[head].CanCollide
                            head.Massless = originalProperties[head].Massless
                        end)
                    end
                end
            end
            -- Clear the saved properties
            originalProperties = {}
        end
    end,
})

-- Size Slider
HitBoxTab:AddSlider('HeadSizeSlider', {
    Text = 'Head Size',
    Min = 2,
    Max = 50,
    Default = 15,
    Rounding = 0,
    Callback = function(Value)
        _G.HeadSize = Value
    end,
})

-- Transparency Slider
HitBoxTab:AddSlider('HeadTransparencySlider', {
    Text = 'Head Transparency',
    Min = 0,
    Max = 1,
    Default = 0.5,
    Rounding = 2,
    Callback = function(Value)
        _G.HeadTransparency = Value
    end,
})

-- Color Picker
HitBoxTab:AddLabel('Head Color'):AddColorPicker('HeadColorPicker', {
    Default = Color3.fromRGB(255, 0, 0),
    Title = 'Head HitBox Color',
    Callback = function(Value)
        _G.HeadColor = Value
    end,
})

-- RGB Color Toggle
HitBoxTab:AddToggle('RGBColorToggle', {
    Text = 'Enable RGB Color',
    Default = false,
    Tooltip = 'Toggles RGB cycling for the head color.',
    Callback = function(Value)
        _G.UseRGBColor = Value
    end,
})

-- RGB Delay Slider
HitBoxTab:AddSlider('RGBDelaySlider', {
    Text = 'RGB Transition Delay (Seconds)',
    Min = 0.01,
    Max = 0.1,
    Default = 0.05,
    Rounding = 3,
    Callback = function(Value)
        _G.RGBDelay = Value
    end,
})

-- Update Loop
task.spawn(function()
    while true do
        if _G.HeadExpanderEnabled then
            for _, player in ipairs(game:GetService('Players'):GetPlayers()) do
                if player ~= game:GetService('Players').LocalPlayer and player.Character and player.Character:FindFirstChild('Head') then
                    local head = player.Character.Head
                    if not originalProperties[head] then
                        -- Save the original properties if not already saved
                        originalProperties[head] = {
                            Size = head.Size,
                            Transparency = head.Transparency,
                            BrickColor = head.BrickColor,
                            Material = head.Material,
                            CanCollide = head.CanCollide,
                            Massless = head.Massless,
                        }
                    end
                    -- Apply the expander settings
                    pcall(function()
                        head.Size = Vector3.new(_G.HeadSize, _G.HeadSize, _G.HeadSize)
                        head.Transparency = _G.HeadTransparency
                        head.BrickColor = BrickColor.new(
                            _G.UseRGBColor and GetNextRGBColor() or _G.HeadColor
                        )
                        head.Material = Enum.Material.Neon
                        head.CanCollide = false
                        head.Massless = true
                    end)
                end
            end
        end
        -- Wait for the RGB delay before cycling again
        task.wait(_G.RGBDelay)
    end
end)

-- Main Tab
local MainGroup = Tabs.Main:AddLeftGroupbox("Player Cham Controls")

local player = game:GetService("Players").LocalPlayer
local RunService = game:GetService("RunService")

-- Variables
local char = player.Character or player.CharacterAdded:Wait()
local isChamEnabled = false
local isRGBEnabled = false
local forceFieldColor = Color3.new(1, 0, 0)

-- Functions
local function applyForceField()
    for _, part in pairs(char:GetDescendants()) do
        if part:IsA("BasePart") then
            part.Material = Enum.Material.ForceField
            part.Color = forceFieldColor
        end
    end
end

local function resetMaterials()
    for _, part in pairs(char:GetDescendants()) do
        if part:IsA("BasePart") then
            part.Material = Enum.Material.Plastic
            part.Color = Color3.new(1, 1, 1)
        end
    end
end

local function startRGBEffect()
    RunService.RenderStepped:Connect(function()
        if isRGBEnabled then
            forceFieldColor = Color3.fromHSV(tick() % 5 / 5, 1, 1)
            if isChamEnabled then
                applyForceField()
            end
        end
    end)
end

-- Event to handle character reset or respawn
player.CharacterAdded:Connect(function(newChar)
    char = newChar
    char:WaitForChild("Humanoid")
    
    if isChamEnabled then
        applyForceField()
    end
end)

startRGBEffect()

MainGroup:AddToggle("ChamToggle", {
    Text = "Enable Player Cham",
    Default = false,
    Tooltip = "Toggles the ForceField effect on your character",
    Callback = function(value)
        isChamEnabled = value

        if isChamEnabled then
            applyForceField()
        else
            resetMaterials()
        end
    end,
})

MainGroup:AddToggle("RGBToggle", {
    Text = "Enable RGB Mode",
    Default = false,
    Tooltip = "Cycles through colors dynamically.",
    Callback = function(value)
        isRGBEnabled = value
    end,
})

MainGroup:AddLabel('Cham Color'):AddColorPicker('ColorPicker', {
    Default = Color3.new(1, 0, 0), -- Default to red
    Title = 'Select ForceField Color', -- Custom title
    Transparency = nil, -- No transparency

    Callback = function(color)
        forceFieldColor = color
        if isChamEnabled and not isRGBEnabled then
            applyForceField()
        end
    end,
})

-- Fun cheats Tab
local SecondGroup = Tabs.Second:AddLeftGroupbox("Fun cheats")

-- Variables
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local localPlayer = Players.LocalPlayer
local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
local rootPart = character:WaitForChild("HumanoidRootPart")

local Noclip = nil
local Clip = nil
local noclipEnabled = false

-- Function to toggle noclip
function noclip()
    Clip = false
    local function Nocl()
        if Clip == false and game.Players.LocalPlayer.Character ~= nil then
            for _, v in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
                if v:IsA('BasePart') and v.CanCollide and v.Name ~= "HumanoidRootPart" then
                    v.CanCollide = false
                end
            end
        end
        wait(0.21) -- basic optimization
    end
    Noclip = game:GetService('RunService').Stepped:Connect(Nocl)
end

-- Function to enable normal collision
function clip()
    if Noclip then Noclip:Disconnect() end
    Clip = true
end

-- Toggle function for LinoriaLib integration
local function toggleNoclip(state)
    noclipEnabled = state

    if noclipEnabled then
        noclip()  -- Start noclip if toggle is on
    else
        clip()  -- Restore collision if toggle is off
    end
end

-- Linoria UI Integration (Make sure to replace SecondGroup with your actual group reference)
SecondGroup:AddToggle("NoclipToggle", {
    Text = "Enable Noclip",
    Default = false,
    Tooltip = "Allows you to pass through objects.",
    Callback = function(state)
        toggleNoclip(state)
    end,
})

-- Listen for respawns and re-initialize the character if needed
localPlayer.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    rootPart = character:WaitForChild("HumanoidRootPart")
    
    -- If noclip was enabled before respawn, re-enable it
    if noclipEnabled then
        noclip()
    end
end)

-- Infinite jump toggle state
local InfiniteJumpEnabled = false
local Player = game.Players.LocalPlayer
local Character = Player.Character or Player.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")

-- Function to handle infinite jump when toggle is enabled
local function handleInfiniteJump()
    -- Listen for JumpRequest event
    game:GetService("UserInputService").JumpRequest:Connect(function()
        if InfiniteJumpEnabled then
            -- Ensure the humanoid is in a jumping state
            local humanoid = game.Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid')
            if humanoid then
                humanoid:ChangeState("Jumping")
            end
        end
    end)
end

-- Toggle for enabling/disabling infinite jump
SecondGroup:AddToggle('InfiniteJumpToggle', {
    Text = 'Infinite Jump',
    Default = false, -- Default state of the toggle
    Tooltip = 'Enable/Disable Infinite Jump',

    Callback = function(state)
        InfiniteJumpEnabled = state
        if InfiniteJumpEnabled then
            print("Infinite Jump enabled!")
            handleInfiniteJump()  -- Start listening for JumpRequest when toggle is on
        else
            print("Infinite Jump disabled!")
        end
    end
})

-- Fun cheats Tab
local ThirdGroup = Tabs.Second:AddRightGroupbox("Local player changer")

ThirdGroup:AddSlider('Walk Speed', {
    Text = 'Change walk speed',
    Default = 16,
    Min = 16,
    Max = 500,
    Rounding = 1,
    Compact = false,

    Callback = function(Value)
        game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = Value
    end
})

ThirdGroup:AddSlider('Jumppower', {
    Text = 'Change jump power',
    Default = 50,
    Min = 50,
    Max = 500,
    Rounding = 1,
    Compact = false,

    Callback = function(Value)
        game.Players.LocalPlayer.Character.Humanoid.JumpPower = Value
    end
})

ThirdGroup:AddSlider('Hip Height', {
    Text = 'Change hip height',
    Default = 2,
    Min = 2,
    Max = 250,
    Rounding = 1,
    Compact = false,

    Callback = function(Value)
        game.Players.LocalPlayer.Character.Humanoid.HipHeight = Value
    end
})

ThirdGroup:AddSlider('Gravity', {
    Text = 'Change Gravity',
    Default = 196.2,
    Min = 0,
    Max = 500,
    Rounding = 1,
    Compact = false,

    Callback = function(Value)
        Game.Workspace.Gravity = Value
    end
})

-- Fun cheats Tab
local FourthGroup = Tabs.Second:AddLeftGroupbox("Field of view")

FourthGroup:AddSlider('Field of view', {
    Text = 'Change Field of view',
    Default = 70,
    Min = 70,
    Max = 120,
    Rounding = 1,
    Compact = false,

    Callback = function(Value)
        workspace.Camera.FieldOfView = Value
    end
})

-- Settings Tab
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)

ThemeManager:ApplyToTab(Tabs.Settings)
SaveManager:LoadAutoloadConfig()


-- Settings tab with SaveManager and ThemeManager
local SettingsGroup = Tabs.Settings:AddLeftGroupbox('Settings')
SettingsGroup:AddButton('Unload UI', function()
    Library:Unload()
end)

SettingsGroup:AddLabel('Menu Keybind'):AddKeyPicker('MenuKeybind', {
    Default = 'End',
    NoUI = true,
    Text = 'Menu keybind',
})

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)

ThemeManager:SetFolder('M3CHub')
SaveManager:SetFolder('M3CHub/Configs')

SaveManager:BuildConfigSection(Tabs.Settings)
ThemeManager:ApplyToTab(Tabs.Settings)

-- Load autoload config if available
SaveManager:LoadAutoloadConfig()

        screen_gui:Destroy()  -- Close the GUI when the button is clicked
    end)

    exit_button.MouseButton1Click:Connect(function()
        print("Exit button clicked!")
        screen_gui:Destroy()  -- Close the GUI when the button is clicked
    end)

    -- Smooth fade-in effect for the entire frame
    frame:TweenSize(UDim2.new(0, 400, 0, 350), "Out", "Quad", 0.5, true)
end

-- Function to fetch the game details like name and thumbnail
function fetch_game_details(place_id)
    local marketplace_service = game:GetService("MarketplaceService")
    local success, game_info = pcall(function()
        return marketplace_service:GetProductInfo(place_id, Enum.InfoType.Asset)
    end)
    
    if success and game_info then
        return game_info.Name, "rbxassetid://" .. game_info.IconImageAssetId
    else
        return nil, nil
    end
end

-- Check if the place ID is valid
local place_id_input = game.PlaceId  -- Get the current place ID dynamically

print("Fetching game details...")
local game_name, game_thumbnail_asset_id = fetch_game_details(place_id_input)

if game_name and game_thumbnail_asset_id then
    create_gui(place_id_input, game_name, game_thumbnail_asset_id)  -- Create and display the GUI with game details
else
    print("Could not fetch game details.")
end
